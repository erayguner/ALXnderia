/**
 * Audit logging middleware.
 *
 * Records every NL2SQL query event into the `audit_log` table for
 * compliance and forensic analysis.  Follows data-minimisation
 * principles: result data is never stored, only metadata.
 *
 * Audit failures are logged but never propagate to the caller,
 * ensuring that a broken audit pipeline does not degrade the
 * primary query flow.
 */

import { executeReadOnly } from '../db/pool';
import type { AuditEntry } from '../../shared/types';

/**
 * Record a query audit entry.
 *
 * Stores: who asked what, what SQL ran, row count, timing, and status.
 * Does NOT store actual result data (data minimisation).
 *
 * @param entry - The audit entry to persist (without `id`, which is
 *                generated by the database).
 */
export async function recordAuditEntry(
  entry: Omit<AuditEntry, 'id'>,
): Promise<void> {
  try {
    await executeReadOnly(
      `INSERT INTO audit_log (
        event_time, tenant_id, actor, action, target_table,
        detail, source_system, integrity_hash
      ) VALUES (
        NOW(), $1, $2, 'NL2SQL_QUERY', 'chat',
        $3::jsonb, 'app',
        encode(digest($3, 'sha256'), 'hex')
      )`,
      [
        entry.tenantId,
        entry.userId,
        JSON.stringify({
          question: entry.question,
          sqlExecuted: entry.sqlExecuted,
          rowCount: entry.rowCount,
          executionTimeMs: entry.executionTimeMs,
          status: entry.status,
          rejectionReason: entry.rejectionReason || null,
        }),
      ],
    );
  } catch (error) {
    // Audit logging must never break the main query flow
    console.error('Failed to record audit entry:', error);
  }
}
